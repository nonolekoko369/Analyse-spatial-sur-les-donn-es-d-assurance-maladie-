---
title: "Analyse des données spatiales liés aux VIH en France"
authors: Astri Ugo, Thomas Nominoë
date: "2025-11-17"
output: html_document
---

# I. Introduction générale

Depuis l’apparition des premiers cas de VIH/sida au début des années 1980, la France a mis en place des politiques de santé publique parmi les plus structurées d’Europe, notamment avec la création de dispositifs de dépistage, de surveillance épidémiologique et d’accès universel aux traitements antirétroviraux. Si la mortalité liée au sida a fortement diminué depuis les années 1990, la circulation du virus reste hétérogène selon les territoires de France continentale, en particulier dans certaines grandes agglomérations.

L’objectif de ce document est d’explorer la répartition spatiale des indicateurs liés au VIH en France à partir de données publiques. À travers l’analyse cartographique et statistique, nous cherchons à mettre en évidence les disparités géographiques, les zones à forte prévalence, ainsi que les dynamiques régionales pouvant éclairer les stratégies de prévention et de prise en charge.\

L’étude mobilise des outils de visualisation, de manipulation de données et de cartographie sous R, notamment via les packages *tidyverse*, *sf* et *leaflet*.\

Ce travail s’inscrit dans une démarche de compréhension des enjeux territoriaux du VIH, en offrant une lecture intuitive et reproductible des données spatiales.

# II. Cadre méthodologique

# III. Analyse du jeu de données

| Variable | Description |
|---------------------------|---------------------------------------------|
| **dept** | Code du département (format numérique, sans zéro initial). |
| **Ntop** | Nombre de personnes vivant avec le VIH (20–29 ans) dans le département. |
| **Npop** | Population totale des 20–29 ans dans le département. |
| **prev** | Prévalence du VIH chez les 20–29 ans (Ntop / Npop). |
| **nb_actes_delinquance** | Nombre total d’actes de délinquance enregistrés dans le département. |
| **taux_delinquance_pour_mille** | Taux de délinquance pour 1 000 habitants. |
| **tx_chomage** | Taux de chômage (en %). |
| **densite_pop** | Densité de population (habitants par km²). |
| **tx_pauvrete** | Taux de pauvreté (part de la population ayant un niveau de vie inférieur à 60% du salaire médian en France) (en %). |
| **revenu** | Revenu annuel moyen par habitant (en milliers d'euros). |

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Préparation des données

Chargement des packages :

```{r, results = "hide"}
library(readr)
library(knitr)
library(tidyverse)
library(corrplot)
library(sf)
library(maps)
library(spdep)
library(tmap)
library(lmtest)
library(spatialreg)
library(skimr)
library(Hmisc)
library(dplyr)
library(tidyr)
library(ggplot2)
library(RColorBrewer)

```

Chargement/Préparation des données :

```{r}
vih <- read_csv("repartition_VIH_20_29_par_dept.csv")

#L'étude se basera sur la France continentale, nous retirons donc la corse

vih <- vih |>
  filter(dept != c("2A", "2B"))

# Remplacer le NA par la moyenne (en excluant le NA)
vih$tx_chomage[is.na(vih$tx_chomage)] <- mean(vih$tx_chomage, na.rm = TRUE)

# Vérifier
sum(is.na(vih$tx_chomage))  # doit être 0 maintenant

```

```{r}
kable(vih[1:10,], caption ="Personnes atteintent de VIH en france, 20-29 ans")

```

## Analyse exploratoire

### Résumé statistique

```{r}
skim(vih)

```

### Matrice de corrélation

```{r}
vih_num <- dplyr::select_if(vih, is.numeric)
cor_matrix <- cor(vih_num, use = "pairwise.complete.obs")
res <- rcorr(as.matrix(vih_num))
p_matrix <- res$P


corrplot(cor_matrix,
         method = "color",
         col = colorRampPalette(c("blue", "white", "red"))(200),
         addCoef.col = "black",
         number.cex = 0.5,
         tl.cex = 0.8,            
         tl.col = "black",
         diag = FALSE,
         type = "upper",          
         sig.level = 0.05)


```

Relation entre le nombre de personnes atteintes du vih et le nombre d'acte de délinquance

```{r}
# Variables explicatives (on remplace densite_pop par ln_densite_pop)
vars <- c("taux_delinquance_pour_mille", 
          "tx_chomage", "ln_densite_pop", "tx_pauvrete", "revenu")

# Création de ln_densite_pop
vih2 <- vih %>%
  mutate(ln_densite_pop = log(densite_pop))

# Passage en format long
vih_long <- vih2 %>%
  select(prev, all_of(vars)) %>%
  pivot_longer(cols = all_of(vars), names_to = "variable", values_to = "valeur")

# Plot
ggplot(vih_long, aes(x = valeur, y = prev)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  facet_wrap(~variable, scales = "free_x") +
  labs(x = "Valeur de la variable", y = "Prévalence VIH",
       title = "Régressions linéaires entre prévalence du VIH et variables socio-économiques") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6))
```

On retrouve une possible corrélation positive dans le log de la densité, le revenu et le taux de délinquance pour mille habitant.

## Représentation cartographique des données

### Heatmap

```{r}
url <- "https://raw.githubusercontent.com/gregoiredavid/france-geojson/master/departements.geojson"
carte_dep <- st_read(url)

vih2 <- vih %>%
  mutate(dept = sprintf("%02d", dept))

carte_vih <- carte_dep %>%
  left_join(vih2, by = c("code" = "dept"))

carte_vih <- carte_vih %>% 
  filter(!code %in% c("2A","2B"))  # retire la Corse


ggplot(carte_vih) +
  geom_sf(aes(fill = prev), color = "white", size = 0.2) +
  scale_fill_gradient(low = "lightyellow", high = "red", name = "Prévalence du VIH") +
  labs(
    title = "Prévalence du VIH (pour 1000 habitants) par département",
    subtitle = "Carte choroplèthe basée sur les codes INSEE"
  ) +
  theme_minimal() +
  theme(panel.grid = element_blank())

```

Une prévalence marquée en région parisienne et dans les département qui ne sont pas quasi-exclusivement ruraux.

# IV. Analyse et discussion des résultats

## Création de la matrice de poids spatiale via contiguité

```{r}
centroids <- st_centroid(carte_vih)  # crée un sf POINT au centre de chaque polygone


tmap_mode("plot")

tm_shape(carte_vih) +
  tm_polygons(
    fill = "prev",             # variable à colorer
    col = "grey25",                  # contour des départements
    fill.scale = tm_scale(values = "Reds"),   # palette
    fill.legend = tm_legend(title = "Prévalence VIH\n(pour 1000 hab.)")
  ) +
  tm_shape(centroids) +
  tm_dots(
    size = 0.2,
    col = "red",
    fill_alpha = 0.6
  ) +
  tm_title("Centroids et Prévalence VIH") +
  tm_layout(frame = FALSE, bg.color = "white")

```

```{r}
# carte_vih : ton sf avec les départements et la prévalence
# queen = TRUE pour contiguïté “Queen” (partage frontière ou coin)
col.nb <- poly2nb(carte_vih, queen = TRUE)

# Vérifier les premiers voisins
head(col.nb)

```

```{r}
col.listw <- nb2listw(col.nb, style = "W")  # style W = row-standardized
summary(col.listw)
```

```{r}
# Centroides pour visualisation
centroids <- st_centroid(carte_vih)
coords_matrix <- st_coordinates(centroids)

plot(st_geometry(carte_vih), col = "lightgrey", border = "white")
plot(col.nb, coords_matrix, add = TRUE, col = "red")

```

## Analyse de l'autocorrélation spatiale

```{r}
xx <- cbind(carte_vih$prev, carte_vih$`Revenu annuel Moyen (en millier d’euros)`, carte_vih$densite_pop)
```

```{r}
wxx <- lag.listw(col.listw,xx) 
head(wxx)
```

```{r}
attributes(col.listw)
```

```{r}
par(mfrow=c(1,2),cex.main=0.7)
boxplot.matrix(xx,main="VIH")
boxplot.matrix(wxx,main="Spatial lag VIH")
```

```{r}
# Ajouter le spatial lag de la prévalence
carte_vih$W_prevalence <- lag.listw(col.listw, carte_vih$prev)

# Transformer en format long et tracer les densités
carte_vih %>%
  st_drop_geometry() %>%
  pivot_longer(cols = c('prev','W_prevalence')) %>%
  ggplot() +
    geom_density(aes(x = value, color = name, fill = name), alpha = 0.3) +
    scale_color_manual(values = brewer.pal(n = 2, name = "Dark2")) +
    scale_fill_manual(values = brewer.pal(n = 2, name = "Dark2")) +
    labs(
      x = "Prévalence VIH",
      y = "Densité",
      title = "Comparaison Prévalence et Spatial Lag",
      color = "Variable",
      fill = "Variable"
    )

```

```{r}

# Transformation logarithme pour densite_pop
carte_vih <- carte_vih %>%
  mutate(ln_densite_pop = log(densite_pop))

# Variables à analyser (avec densité logarithmée)
vars <- c("prev", "tx_chomage", "ln_densite_pop", "tx_pauvrete", "revenu")

# Création de la matrice de poids (voisins)
nb <- poly2nb(carte_vih)           
lw <- nb2listw(nb, style = "W")    

# Créer un data.frame long avec spatial lag pour chaque variable
long_list <- lapply(vars, function(v) {
  data.frame(
    variable = v,
    value = carte_vih[[v]],
    W_value = lag.listw(lw, carte_vih[[v]])
  )
})

carte_long <- bind_rows(long_list)

# Plot Moran pour toutes les variables en facettes
ggplot(carte_long, aes(x = value, y = W_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  facet_wrap(~variable, scales = "free") +
  labs(title = "Moran plots pour plusieurs variables",
       x = "Valeur de la variable",
       y = "Spatial lag") +
  theme_minimal() +
  theme(
    plot.title = element_text(color = "black", size = 10, face = "bold", hjust = 0.5),
    axis.text = element_text(size = 6),
    axis.title = element_text(size = 8)
  )


```

Les variables (à part peut-être prev) semblent être auto-corrélées positivement.

### Indice d'autocorrélation spatiale

```{r}
morantesVIH <-moran.test(carte_vih$prev,col.listw,randomisation=FALSE,alternative="greater")
morantesVIH
```

La p-value est inférieure à 1% donc on rejette l'hypothèse nulle d'absence d'autocorrélation spatiale. La statistique I de Moran est positive et relativement élevé donc la prévalence du VIH présente une autocorrélation spatiale significative et positive.

```{r}
moran.plot(x=carte_vih$prev,col.listw,xlab="CRIME",ylab="Spatial Lag de la variable prev",labels=as.character(columbus$POLYID),main=paste("Moran Plot I = ",round(morantesVIH$estimate[1],3)))

```

test de moran sur toutes nos variables d'intéret

```{r}
# Colonnes numériques pertinentes
xx <- carte_vih %>% 
  st_drop_geometry() %>%        
  select(prev, Ntop, Npop, revenu, tx_pauvrete, tx_chomage, nb_actes_delinquance)

# Calcul du test de Moran pour chaque variable
moran_results <- lapply(names(xx), function(v) {
  x_clean <- xx[[v]]
  
  # Retirer les NA si nécessaire
  if(any(is.na(x_clean))) x_clean <- na.omit(x_clean)
  
  test <- moran.test(x_clean, listw = col.listw)  # col.listw doit correspondre à l'ordre/longueur
  data.frame(
    Variable = v,
    Moran_I = test$estimate["Moran I statistic"],
    Expectation = test$estimate["Expectation"],
    Variance = test$estimate["Variance"],
    p_value = test$p.value
  )
})

# Résultat combiné et trié
moran_summary <- bind_rows(moran_results) %>% arrange(desc(Moran_I))

moran_summary



```

### LISA

```{r}
# Local Moran (LISA)
lisa <- localmoran(carte_vih$prev, col.listw)

# Ajouter les résultats à ton sf
carte_vih$Ii <- lisa[,1]      # valeur de Moran local
carte_vih$Z_Ii <- lisa[,4]    # z-score
carte_vih$p_value <- lisa[,5] # p-value

carte_vih$cluster <- NA
carte_vih$cluster[carte_vih$Ii > 0 & carte_vih$p_value < 0.05] <- "High-High"
carte_vih$cluster[carte_vih$Ii < 0 & carte_vih$p_value < 0.05] <- "Low-Low"
carte_vih$cluster[carte_vih$Ii > 0 & carte_vih$p_value >= 0.05] <- "Insignificant"
carte_vih$cluster[carte_vih$Ii < 0 & carte_vih$p_value >= 0.05] <- "Insignificant"

tmap_mode("plot")

tm_shape(carte_vih) +
  tm_polygons(
    col = "cluster",
    palette = c("red", "yellow", "blue","grey80"),
    title = "LISA clusters"
  ) +
  tm_layout(frame = FALSE)

```

Les régions d'Ile-de-France apparaissent comme des hot spots (zones de prévalences élevées entourés d'autres prévalences élevées). Le lot, le Cantal, la Lozère et les vosges sont, selon le graphique, aussi des hot spots mais leurs prévalences ne sont vraiment pas très élevées pourtant. La Côte-d'Or et le Doubs sont quant à eux des cold spots (zones de prévalences faibles entourés d'autres prévalences faibles).

### Estimation du modèle adéquat

### OLS Classique

```{r}
# Formule OLS
ols_formula <- prev ~ revenu + tx_pauvrete + tx_chomage + nb_actes_delinquance

# Estimation du modèle OLS
ols_model <- lm(ols_formula, data = carte_vih)

# Résumé classique
summary(ols_model)

# Test d'homoscédasticité (Breusch-Pagan)
bptest(ols_model)

# Test de Moran sur les résidus
Moran_Res <- lm.morantest(ols_model, col.listw, alternative = "two.sided")
Moran_Res
```

Le modèle OLS explique une part importante de la variance de la prévalence du VIH (R² ajusté = 0,629). Seuls revenu et nb_acte_delinquance sont significativement associés à la prévalence, tandis que le taux de pauvreté et le taux de chômage ne le sont pas. Le test de Breusch-Pagan (p = 0,023) suggère désormais une légère hétéroscédasticité des résidus. De plus, l’autocorrélation spatiale des résidus reste significative (Moran I = 0,220 ; p \< 0,001), indiquant que des effets spatiaux ne sont toujours pas capturés par l’OLS.

#### Modèles SAR et SEM

```{r}
lm.LMtests(ols_model,listw = col.listw,test="LMerr")

lm.LMtests(ols_model,listw = col.listw,test="LMlag")
```

Les tests de Rao montrent que l’autocorrélation spatiale est significative à la fois dans les résidus (RSerr, p = 0,001) et dans la variable dépendante (RSlag, p \< 0,001). Cela indique que le modèle OLS ne capture pas correctement la structure spatiale des données. Il serait donc préférable d’utiliser un modèle spatial (SAR ou SEM) pour tenir compte à la fois des effets de dépendance de la variable dépendante et des autocorrélations dans les erreurs.

#### Modèle SLX

```{r}
# Modèle SLX : inclusion des covariables spatialisées
SLX_prev <- lmSLX(
  prev ~ revenu + tx_pauvrete + tx_chomage + nb_actes_delinquance,
  listw = col.listw,
  data = carte_vih
)

# Résumé des résultats
summary(SLX_prev)
```

Le modèle SLX montre que, comme dans les modèles SEM et SAR, la prévalence du VIH est significativement associée au nombre d’actes de délinquance (β = 8,26e-08, p \< 0,0001) et, plus faiblement, au chômage. Le revenu et le taux de pauvreté ne sont pas significatifs. Les effets spatiaux des covariables (lag.revenu, lag.tx_pauvrete, lag.tx_chomage, lag.nb_actes_delinquance) ne sont pas significatifs, indiquant que la prévalence d’une commune n’est pas fortement influencée par les valeurs des covariables dans les communes voisines. Le SLX capture donc surtout les effets directs des variables locales, sans mettre en évidence d’effets spatiaux indirects significatifs.

### Evaluation des modèles retenus

#### Modèle SEM

```{r}

# Estimation du SEM sur la variable 'prev'
SEM_prev <- errorsarlm(
  prev ~ 
         revenu + 
         tx_pauvrete + tx_chomage + nb_actes_delinquance,
  listw = col.listw,   # matrice de poids spatiaux
  data = carte_vih
)

# Résumé des résultats
summary(SEM_prev)
```

Le modèle Spatial Error (SEM) montre que la prévalence du VIH est significativement associée au revenu et au nombre d’actes de délinquance, tandis que le taux de pauvreté et le taux de chômage n’ont pas d’effet significatif. Le paramètre lambda (λ = 0,455, p \< 0,001) indique une autocorrélation spatiale importante dans les résidus, ce qui confirme que le modèle OLS ne capturait pas correctement la dépendance spatiale. L’ajustement du SEM améliore la qualité du modèle, avec un AIC plus faible et une variance résiduelle réduite, permettant des estimations plus fiables des effets des variables explicatives.

```{r}
#on veut plot les erreurs

carte_vih$sem_res <- residuals(SEM_prev)

tmap_mode("plot")

tm_shape(carte_vih) +
  tm_polygons(
    fill = "sem_res",
    fill_alpha = 0.5,
    palette = "-brewer.rd_yl_bu",           # palette inversée
    fill.scale = tm_scale_intervals(n = 7, midpoint = 0),  # centre sur 0 pour résidus
    fill.legend = tm_legend(title = "Résidus SEM"),
    id = "Ntop"
  )

```

Les résidus ont l'air bien répartis et proche de 0 donc le SEM corrige efficacement l'autocorrélation.

#### Modèle SAR

```{r}
# Estimation du SAR sur la variable 'prev'
SAR_prev <- lagsarlm(
  prev ~ 
    revenu + 
    tx_pauvrete + 
    tx_chomage + 
    nb_actes_delinquance,
  listw = col.listw,   # matrice de poids spatiaux
  data = carte_vih
)

# Résumé des résultats
summary(SAR_prev)
```

Le modèle Spatial Lag (SAR) confirme, comme le SEM, que la prévalence du VIH est significativement associée au revenu et au nombre d’actes de délinquance, tandis que la pauvreté et le chômage restent non significatifs. Le paramètre spatial rho (ρ = 0,36, p \< 0,001) met en évidence une dépendance spatiale substantielle dans la variable dépendante elle-même, là où le SEM captait une autocorrélation dans les résidus. L’ajustement est amélioré par rapport au modèle OLS (AIC = –345 contre –335), et l’absence d’autocorrélation résiduelle (p = 0,85) montre que le SAR capture pleinement la structure spatiale du phénomène.

```{r}
# Ajouter les résidus du SAR à la carte
carte_vih$sar_res <- residuals(SAR_prev)

tmap_mode("plot")

tm_shape(carte_vih) +
  tm_polygons(
    fill = "sar_res",
    fill_alpha = 0.5,
    palette = "-brewer.rd_yl_bu",                  # palette inversée
    fill.scale = tm_scale_intervals(n = 7, midpoint = 0),  # centre sur 0 pour résidus
    fill.legend = tm_legend(title = "Résidus SAR"),
    id = "Ntop"
  )

```

Même constat : les résidus sont bien répartis et proches de 0 donc le modèle SAR corrige bien l'autocorrélation.

#### Modèle SAC (SEM + SAR)

```{r}
# Estimation du SAC sur la variable 'prev'
SAC_prev <- sacsarlm(
  prev ~ 
    revenu + 
    tx_pauvrete + 
    tx_chomage + 
    nb_actes_delinquance,
  listw = col.listw,   # matrice de poids spatiaux
  data = carte_vih,
  type = "sac"         # modèle combiné SAR + SEM
)

# Résumé des résultats
summary(SAC_prev)

```

Le modèle SAC montre une dépendance spatiale modérée de la prévalence (ρ ≈ 0,316, p ≈ 0,056), tandis que l’autocorrélation des erreurs est faible et non significative (λ ≈ 0,08, p ≈ 0,74). Parmi les variables explicatives, le revenu et le nombre d’actes de délinquance ont un effet positif et significatif sur la prévalence, alors que le taux de pauvreté et le taux de chômage ne sont pas significatifs. Le modèle améliore significativement l’ajustement par rapport à un modèle linéaire classique (LR test p = 0,00245) et présente de faibles résidus, indiquant un bon ajustement global.

#### Synthèse

```{r}
# Comparer les AIC
AICs <- c(
  OLS = AIC(ols_model),
  SEM = AIC(SEM_prev),
  SAR = AIC(SAR_prev),
  SAC = AIC(SAC_prev)
)

print(AICs)

# Visualisation rapide
plot(AICs, type = "h", lwd = 1.5, xaxt = "n", xlab = "Modèles", ylab = "AIC")
axis(1, at = 1:4, labels = names(AICs))
text(1:4, par("usr")[3] - 0.5, labels = names(AICs), srt = 45, adj = 1, xpd = TRUE)

# Mettre un cercle sur le meilleur modèle
symbols(
  x = which.min(AICs),
  y = AICs[which.min(AICs)],
  circles = 0.2,
  fg = 2,
  lwd = 2,
  inches = FALSE,
  add = TRUE
)


```

Parmi les modèles comparés, le SAR présente le plus petit AIC (-345,40), indiquant qu’il offre le meilleur compromis entre ajustement et complexité pour ces données. Le SEM et le SAC ont des AIC légèrement plus élevés (-343,84 et -343,46), tandis que l’OLS a le plus grand AIC (-335,44), montrant qu’il s’ajuste moins bien en ignorant la structure spatiale. Ainsi, l’inclusion de l’effet spatial (SAR) améliore clairement le modèle, tandis que l’ajout d’une autocorrélation des erreurs (SAC) n’apporte pas de gain significatif.

# V. Conclusion générale et perspective

# Références bibliographiques

# Annexes
